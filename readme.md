# tinytast: 轻量级单元测试框架

只需一个头文件的超轻量级单元测试框架。因其轻量，故不名 test ，而另名 tast 。

依赖低，只用到 C++ 标准库（甚至无需 C++11 功能）。

## 核心功能宏与思想

* 提供一个统一的宏 `COUT` 用以检测与预测比较变量或表达式的值。其名来源于 `std::cout`，初衷即是将信息打印出来看看是啥。
* 提供 `DEF_TAST` 宏定义一个测试用例函数（对象），然后用 `RUN_TAST` 宏自动执行所有按此定义的测试用例。且可在命令行参数指定执行特定的测试用例。
* 也可以自由定义无参无返回值的测试函数 `void()` 并手动安排调用。不过若用 `TAST` 宏调用，可额外打一行标题信息，然后可用 `TAST_RESULT` 打印测试统计信息。

## 使用方法最简示例

只需在测试文件中包含 `tinytast.hpp` 头文件，然后用 `DEF_TAST` 定义一系列类似
`void()` 函数的代码块，其中可用 `COUT` 输出或比较感兴趣的值，最后在 `main()`
函数中调用 `RUN_TAST` 。

```cpp
#include "tinytast.hpp"

DEF_TAST(test_name, "测试用例说明")
{
    COUT(sizeof(int));
    COUT(sizeof(int), 4);
    COUT(sizeof(int)==4, true);
}

int main(int argc, char** argv)
{
    return RUN_TAST(argc, argv);
}
```

编译、运行大约有如下输出：其中 `COUT` 单参数时只观察结果，双参数时比较结果并给
出正确或通过与否的判据，然后有额外统计汇总信息。

```
## run test_name()
|| sizeof(int) =~? 4
|| sizeof(int) =~? 4 [OK]
|| sizeof(int)==4 =~? ture [OK]
<< [PASS] test_name within 81 us

## Summary
<< [PASS] 1
<< [FAIL] 0
```

可以由多个测试 `*.cpp` 源文件编译链接在一起，当然只能有一个 `main()` 定义。 

另注：[v0.1](https://github.com/lymslive/couttast/tree/v0.1) 极简版不支持
`DEF_TAST` 定义用例及 `RUN_TAST` 运行用例。只支持 `TAST` 调用普通 `void()` 函
数。

## 构建指引

只用头文件的话，其实不需要特别地构建。但本仓库也提供了一些可运行示例及浅封装库，
可用 `make` 简单构建，除了 C++ 标准库没有其他第三库依赖。

```bash
make
make example
```

在本仓库主目录上提供了 `makefile` ，直接 `make` 会生成 `lib/` 与 `bin/` 子目录。
但这不是必须的，用户可以直接只使用 `include` 的头文件。

### 用 CMake 构建

也提供了 `cmake` 构建系统，例如可如下构建与安装：

```bash
mkdir build
cd build
cmake .. -DCMAKE_INSTALL_PREFIX=$HOME
make
make test
make install
```

用 `cmake` 工具时，按惯例构建工作在单独的 `build/` 子目录下进行。最后一步安装
至个人 `$HOME` 下的几个子目录，`include/couttast` 、`lib/` 与 `bin/` ，这是为
了避免 `/usr/local` 的写权限限制。

如果在前面步骤 `cmake ..` 时不加 `CMAKE_INSTALL_PREFIX` 选项参数，则默认安装至
系统目录 `/usr/local` 。安装至系统目录后，在写具体的单元测试程序时可直接使用，
或集成至其他 CMake 构建的项目。如果安装在 `$HOME` 目录或其他目录，则可能需要在
构建单元测试程序时调整相应的编译参数。

### 构建单元测试程序

有三种方法构建可执行测试程序（命令行程序），可参见 `example/basiccpp-*` 的几个子目录。

1. 自己写 `main` 函数。可以在调用 `RUN_TAST` 之前作些特殊的预处理。
2. 链接静态库 `lib/libtast_main.a` ，自己不用写 `main` 函数，只关注写测试用例。
   `libtast_main.a` 的功能相当简单，就只为提供个 `main` 入口函数。
3. 自己将测试用例编译为动态链接库，要求导出 `tast_main()` 函数，该函数一般会最
   终调用 `RUN_TAST` 宏。然后用 `bin/tast_drive` 程序驱动编译的测试动态库，
   将动态库作为第一个命令行参数，剩余参数会传给内部的测试库。

单元测试驱动单元测试动态链接库的使用方式如下：

```bash
bin/tast_drive libmytast.so --list
bin/tast_drive libmytast.so [test_name_fileter]
```

注意加载动态库可能要导出环境变量 `$LD_LIBRARY_PATH`，毕竟一般不会将测试动态库
放到系统路径中。因为动态链接库的方式比较复杂，也更多陷阱，在没特殊需求时，建议
使用前两种方法构建独立可运行的单元测试程序。

本测试库所支持的命令行参数见后文。

## 单元测试库宏定义详解

### COUT 语句宏

顾名思义，`COUT` 就是将一个表达的值打印出来。支持任意类型，只要其支持 `<<` 操
作符。

* 单参数 `COUT(expr)` ：打印 `expr` 表达式字面量及其值，使其输出信息更有可读意义，且更易找到源文件互为参照。
* 双参数 `COUT(expr, expect)` ：在单参数的基础上扩展，比较 `expr` 与 `expect`
  的值，如果相等，在行尾打上 '[OK]' 的标记，否则打上 `[NO]` 的标记。比较失败后
  也会再打印 `expect` 的值。表达式与预期值的类型可以不同，但要求支持 `==` 操作重载。
* 浮点数三参数 `COUT(expr, expect, limit)`：因为浮点精度原因，直接用 `==` 比较
  浮点数易出问题，所以允许提供额外参数指定精度。

但是也应尽量避免浮点数比较，果真需要，可显式如下调用：

```cpp
COUT(abs(expr-expect) <= limit, true);
```

单参数的 `COUT` 也可称为输出宏，双参数（以上）则称为断言宏。
对于断言宏还有两个扩展变种，可选使用。

* `COUTF(expr, expect)`: 只有当断言失败时才输出信息，用于减少成功时的输出信息。
* `COUT_ASSERT(expr, expect)`: 断言失败时会因 `return` 终止当前测试函数，可避
  免因一个关键失败导致后续连续失败甚至异常。

### DESC 描叙宏

另外提供两个纯输出函数，仅为改善输出信息的可读性，可选使用。

* `DESC(msg, ...)`：类似 `printf` 调用。
* `CODE(statement)`：执行语句前打印出该语句。

### TAST 宏半自动测试

* `TAST(test_fun)`：调用测试函数名（`void()`类型的函数指针）
* `TAST_RESULT`：打印测试统计信息

为不失灵活性，完全可以按常规编程习惯定义一些函数，只要这些函数用到 `COUT` 宏就
能输出与比较。然后手动在 `main()` 中组织调用这些函数。不过若是 `void()` 类型的
函数，则可用 `TAST()` 宏来调用，将会额外跟踪加入统计信息 `TAST_RESULT`。

### TAST 宏定义与自动测试

* `DEF_TAST(case_name, desc)`：相当于测试函数 `void tast_case()` 加强版，还可
以为该测试用例附加一段描叙说明。本质上是定义了一个类及其单例。随后的 `{}` 代
码块是该类的一个虚函数实现。
* `RUN_TAST()`：自动执行由 `DEF_TAST` 定义的所有测试用例，且按测试名的字典序依
次执行。可以传入 `(argc, argv)` 命令行参数，以筛选执行特定的测试用例。

在定义测试用例时，参数 `case_name` 要求是合法的 C++ 符号（不加双引号），`desc` 是
任意描叙字符串（加双引号）。描叙参数也可省略，但建议加上便于人工管理测试用例。

在运行测试用例时，`RUN_TAST()`最后会自动调用 `TAST_RESULT` 宏，返回的是失败用
例个数，可直接当作 `main` 的返回值， `0`表示测试成功。

## 单元测试程序用法

当利用本单元测试库构建出可执行的单元测试程序后，有一些用法值得注意。

### 命令行参数解析

当将多个输入的命令行参数传给 `RUN_TAST()` 时，除特定选项外，将依次对其解析：

* 如果参数完全匹配某个测试名，则只运行该用例。
* 如果参数仅是单字符，则只运行以该字符开头的用例。
* 如果参数以 `^` 开头或以星号 ` * ` 结尾，则查找特定前缀的用例。
* 如果参数以 `$` 结尾或以星号 ` * ` 开头，则查找特定后缀的用例。
* 其他无特殊字符时，查找任意包含给定参数的用例。

这些规则应该符合直觉与方便使用。暂不打算支持完整正则表达式，以保证库的轻量化。

已知 bug （特性），多个命令参数筛选的测试用例没有互斥与唯一性。即在非用例全名
的情况下，有可能多次匹配到同一个用例，重复运行。

最典型的用法时不带任何参数运行所有测试用例，以及带上全名单测某一个或几个测试用
例。良好的单元测试用例设计，应该使每一个单元测试可独立运行，不依赖其他用例的特
定顺序，重复运行也应没有副作用。

作为选项的命令行参数，都以一个或多个 `-` 开头，如果选项有参数，只能用 `=` 分隔
选项名及其参数，即形如 `--key` 或 `--key=val` 格式。不支持用空格分隔（否则会当
作普通的测试用例参数）。约定统一的选项参数格式也是为实现轻量化考虑。

目前支持的选项有以下几个：

* `--help` : 输出简要帮助信息，可用选项。
* `--list` ：列出所有测试用例名，而不实际运行测试。
* `--List` ：列出所有测试用例名及其描叙，即 `DEF_TAST` 宏定义时的两个参数。
* `--cout=fail` ：只输出 `COUT` 断言失败的语句，相当于 `COUTF` 效果。
* `--cout=silent` ：与 `fail` 类似，但输出的信息还更精简，单参数 `COUT` 输出宏
  与纯描叙性的 `DESC` 宏也被沉默，不再有输出。`--cout` 只能取这两个值有意义，
  其他值都等效于 `all` 表示默认输出全部信息。

另注，`--list` 与 `--help` 一样是短路的，输出信息后直接退出，因此也会忽略后面
提供的测试名筛选参数，而是列出所有测试名。如需查询特定测试名，可管道至 `grep`
或其他更过滤工具。

```
./tast_program --list | grep something
```

### diff 模拟回归测试

```bash
./tast_program > tast.cout
# after some time for fix ...
mv tast.cout tast.bout
./tast_program > tast.cout
diff tast.cout tast.bout
```

可将不同时段的测试输出保存文件，用 diff 比较法模拟回归测试。不过此法要注
意的是测试中不宜输出指针地址，因为不同运行时内存地址不可能做到保持一致。

另外，如果测试代码中主要用到双参数 `COUT` 测试，一般看统计结果全部通过达到回归
测试的目的。即修改程序后，原来通过的单元测试用例集，应该仍保持通过。diff 比较
法更适用于测试代码中大量使用单参数 `COUT` 不能自动判断通过与否的情况。

### 性能测试 

利用宏 `TIME_TAST` 可以简便快捷地进行性能测试。它可以重复运行由 `DEF_TAST` 定
义的某个测试用例若干次，统计每次的运行时间，并求平均值。每次运行时会调用 `sleep`
暂停 1 秒，最后打印汇报结果。

它可接收 1 至 3 个参数，只有第一个参数用例名是必须的，后面两个有默认值：

* `name`: 测试用例名，即由 `DEF_TAST` 定义的名称。
* `times`: 重复运行次数，默认 10 次。
* `verbose`: 是否打印每次运行的时间，默认 `true`。但如果启动测试程序时传入了命
  令行参数 `--cout=silent` ，那它也不会打印中间结果。
* `return`: 返回值就是平均时间，单位是微秒。

用于性能测试的用例，虽然（为保持一致）也用 `DEF_TAST` 定义，但由于其设计目的不
同，一般不在用例函数内用 `COUT` 宏比较结果，也就是应该必定 `PASS` 的用例。

而调用 `TIME_TAST` 触发性能测试的语句，可以放在另一个 `DEF_TAST` 的用例中，这
样就可以从命令行参数选定运行该性能测试用例。但如果按默认无命令行参数时，那个被
性能测试的用例也会额外运行一次，不过这一般不是大问题。

在实践中，也可以将功能测试与性能测试分开，编译为不同的可执行测试程序。在性能测
试程序中，可以简单地将若干 `TIME_TAST` 调用放在 `main()` 函数中。因为对于性能
测试，它需要的是运行时间报告，须由人工分析，一般无法预测或比较运行时间多少。

但是可以利用 `TIME_TAST` 的返回值，比较两个算法实现的相对大小，也就能期望预测
一种算法比另一种更快。

## 历史版本及主要变更记录

### v0.2

核心文件：`tinytast.hpp` 。

单头文件简易版。增加了 `DEF_TAST` 宏定义测试用例，在 `main()` 入口函数只需用
`RUN_TAST` 自动调用所有被定义的测试用例。可用命令参数指定筛选运行部分测试用例，
并安排测试顺序。内部采用一个全局单例对象管理所有测试用例，每个 `DEF_TAST` 的用
例除了名称与可选描叙外，函数体可按普通 `void` 函数编写，用 `COUT` 宏比较结果。

提供一些应用示例，及简单驱动程序或封装库，支持 `make` 与 `cmake` 构建。

### v0.1

核心文件：`tast_util.hpp` 。

极简速成版。除了 `COUT` 比较观察宏外，只定义了 `TAST` 宏调用普通 `void` 函数，
用 `TAST_RESULT` 宏汇报结果。没有专门语法定义测试用例，需在 `main()` 函数中手
动调用作为用例的 `void` 函数或用 `TAST` 宏封装调用。
